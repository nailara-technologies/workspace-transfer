#!/usr/bin/perl
# question-answer-system.pl - Out-of-band communication for models
use v5.24;
use strict;
use warnings;
use Time::Piece;
use File::Path qw(make_path);

say "üîî QUESTION-ANSWER OUT-OF-BAND COMMUNICATION SYSTEM";
say "=" x 80;
say "";

my $repo_root = '/home/claude/workspace-transfer';
my $questions_log = "$repo_root/QUESTIONS.log";
my $questions_answered_log = "$repo_root/QUESTIONS_ANSWERED.log";

# Create logs if they don't exist
unless (-f $questions_log) {
    open my $fh, '>', $questions_log or die "Cannot create $questions_log: $!";
    print $fh "# Question Log - Unanswered Questions\n";
    print $fh "# Format: [TIMESTAMP] STATUS | TARGET | QUESTION\n";
    print $fh "# STATUS: PENDING, ANSWERED, ACKNOWLEDGED\n";
    print $fh "# Auto-generated by question-answer-system.pl\n\n";
    close $fh;
    say "‚úÖ Created $questions_log";
}

unless (-f $questions_answered_log) {
    open my $fh, '>', $questions_answered_log or die "Cannot create $questions_answered_log: $!";
    print $fh "# Question Log - Answered Questions Archive\n";
    print $fh "# Format: [TIMESTAMP] ANSWERED | TARGET | Q: ... | A: ...\n";
    print $fh "# Auto-generated by question-answer-system.pl\n\n";
    close $fh;
    say "‚úÖ Created $questions_answered_log";
}

say "üìã SYSTEM OVERVIEW";
say "-" x 80;
say "";
say "Communication Channels:";
say "  1. QUESTION file      - User asks question";
say "  2. QUESTION.<model>   - User asks specific model";
say "  3. ANSWER file        - User provides answer";
say "  4. QUESTIONS.log      - Pending questions log";
say "  5. Git hook           - Auto-check on commits";
say "";

# Function: Log a question
sub log_question {
    my ($target, $question, $priority) = @_;
    $target //= 'any-model';
    $priority //= 'NORMAL';
    
    my $timestamp = localtime->strftime('%Y-%m-%d %H:%M:%S');
    
    open my $fh, '>>', $questions_log or die "Cannot append to $questions_log: $!";
    print $fh "[$timestamp] PENDING | $target | PRIORITY:$priority | $question\n";
    close $fh;
    
    say "‚úÖ Question logged: $target";
}

# Function: Check for QUESTION files
sub check_question_files {
    my @question_files = glob("$repo_root/QUESTION*");
    @question_files = grep { -f $_ && !/\.md$/ } @question_files;
    
    return unless @question_files;
    
    say "üì¨ Found " . scalar(@question_files) . " question file(s)";
    say "-" x 80;
    
    for my $qfile (@question_files) {
        my $filename = $qfile;
        $filename =~ s/^\Q$repo_root\E\/?//;
        
        # Determine target model
        my $target = 'any-model';
        if ($filename =~ /^QUESTION\.(.+)$/) {
            $target = $1;
        }
        
        # Read question
        open my $fh, '<', $qfile or do {
            warn "Cannot read $qfile: $!";
            next;
        };
        my $question = do { local $/; <$fh> };
        close $fh;
        
        chomp $question;
        
        # Determine priority
        my $priority = 'NORMAL';
        if ($question =~ /^\s*URGENT:/i) {
            $priority = 'URGENT';
            $question =~ s/^\s*URGENT:\s*//i;
        }
        
        say "üì® Question for: $target";
        say "   Priority: $priority";
        say "   Content: " . substr($question, 0, 80) . (length($question) > 80 ? "..." : "");
        
        # Log it
        log_question($target, $question, $priority);
        
        # Delete file
        unlink $qfile or warn "Cannot delete $qfile: $!";
        say "   ‚úÖ Processed and deleted";
        say "";
    }
}

# Function: Check for ANSWER files
sub check_answer_files {
    my @answer_files = glob("$repo_root/ANSWER*");
    @answer_files = grep { -f $_ && !/\.md$/ } @answer_files;
    
    return unless @answer_files;
    
    say "üì¨ Found " . scalar(@answer_files) . " answer file(s)";
    say "-" x 80;
    
    for my $afile (@answer_files) {
        my $filename = $afile;
        $filename =~ s/^\Q$repo_root\E\/?//;
        
        # Read answer
        open my $fh, '<', $afile or do {
            warn "Cannot read $afile: $!";
            next;
        };
        my $answer = do { local $/; <$fh> };
        close $fh;
        
        chomp $answer;
        
        say "üì® Answer received:";
        say "   Content: " . substr($answer, 0, 80) . (length($answer) > 80 ? "..." : "");
        
        # Find matching pending question and mark answered
        open my $qlog, '<', $questions_log or die "Cannot read $questions_log: $!";
        my @questions = <$qlog>;
        close $qlog;
        
        # Update most recent PENDING question to ANSWERED
        my $matched = 0;
        for my $i (reverse 0..$#questions) {
            if ($questions[$i] =~ /^\[([^\]]+)\] PENDING \| ([^|]+) \| (?:PRIORITY:(\w+) \| )?(.+)$/) {
                my ($timestamp, $target, $priority, $question) = ($1, $2, $3, $4);
                $priority //= 'NORMAL';
                
                # Move to answered log
                open my $alog, '>>', $questions_answered_log or die $!;
                my $now = localtime->strftime('%Y-%m-%d %H:%M:%S');
                print $alog "[$now] ANSWERED | $target | PRIORITY:$priority\n";
                print $alog "  Q: $question\n";
                print $alog "  A: $answer\n\n";
                close $alog;
                
                # Remove from pending
                $questions[$i] = '';
                $matched = 1;
                last;
            }
        }
        
        if ($matched) {
            # Rewrite questions log without answered question
            open my $qlog, '>', $questions_log or die $!;
            print $qlog grep { $_ } @questions;
            close $qlog;
            
            say "   ‚úÖ Matched with pending question";
        } else {
            say "   ‚ö†Ô∏è  No pending question found (standalone answer)";
        }
        
        # Delete file
        unlink $afile or warn "Cannot delete $afile: $!";
        say "   ‚úÖ Processed and deleted";
        say "";
    }
}

# Function: Show pending questions
sub show_pending_questions {
    open my $fh, '<', $questions_log or die "Cannot read $questions_log: $!";
    my @lines = <$fh>;
    close $fh;
    
    my @pending = grep { /PENDING/ } @lines;
    
    if (@pending) {
        say "üìã PENDING QUESTIONS (" . scalar(@pending) . ")";
        say "-" x 80;
        for my $line (@pending) {
            if ($line =~ /^\[([^\]]+)\] PENDING \| ([^|]+) \| (?:PRIORITY:(\w+) \| )?(.+)$/) {
                my ($timestamp, $target, $priority, $question) = ($1, $2, $3, $4);
                $priority //= 'NORMAL';
                
                my $prefix = $priority eq 'URGENT' ? 'üî¥' : 'üü°';
                say "$prefix [$timestamp] ‚Üí $target";
                say "   $question";
                say "";
            }
        }
    } else {
        say "‚úÖ No pending questions";
    }
}

# Function: Create git hook
sub create_git_hook {
    my $hook_file = "$repo_root/.git/hooks/post-commit";
    
    my $hook_content = <<'EOF';
#!/bin/bash
# post-commit hook - Check for out-of-band QUESTION/ANSWER files
# Auto-generated by question-answer-system.pl

cd "$(git rev-parse --show-toplevel)"

# Check if question-answer-system.pl exists
if [ -f "question-answer-system.pl" ]; then
    echo "üîî Checking for questions/answers..."
    perl question-answer-system.pl --check
    
    # If there are pending questions, alert
    if grep -q "PENDING" QUESTIONS.log 2>/dev/null; then
        echo ""
        echo "‚ö†Ô∏è  PENDING QUESTIONS DETECTED"
        echo "   Run: perl question-answer-system.pl --show"
        echo "   To see what needs attention"
        echo ""
    fi
fi
EOF

    open my $fh, '>', $hook_file or die "Cannot create git hook: $!";
    print $fh $hook_content;
    close $fh;
    
    chmod 0755, $hook_file or die "Cannot make hook executable: $!";
    
    say "‚úÖ Created git post-commit hook: $hook_file";
}

# Function: Generate documentation
sub generate_documentation {
    my $doc_file = "$repo_root/QUESTION_ANSWER_SYSTEM.md";
    
    my $doc_content = <<'EOF';
# Question-Answer Out-of-Band Communication System

**Purpose**: Enable asynchronous communication between user and models without interrupting ongoing work.

---

## üéØ Core Concept

Models work autonomously but may need clarification or user input. Instead of aborting work, questions can be logged and answered out-of-band. Models check for questions/answers at natural checkpoints (commits).

---

## üìÅ File-Based Communication

### User Asks Question

**General Question (any model can answer)**:
```bash
echo "How should I prioritize the filesystem vs network work?" > QUESTION
git add QUESTION
git commit -m "User question"
# QUESTION file auto-processed and deleted by git hook
```

**Targeted Question (specific model)**:
```bash
echo "Can you review my Perl code in core/?" > QUESTION.claude
git add QUESTION.claude  
git commit -m "Question for Claude"
# Logged with target: claude
```

**Urgent Question**:
```bash
echo "URGENT: Stop current work, critical bug found in BMW analysis" > QUESTION
git add QUESTION
git commit -m "Urgent question"
# Logged with URGENT priority
```

### User Provides Answer

When a model asks a question (logged in QUESTIONS.log), user responds:

```bash
echo "Prioritize filesystem integration first, network can wait" > ANSWER
git add ANSWER
git commit -m "Answer to model question"
# Matches most recent pending question, marks as answered
```

---

## üìã Question Logging

### QUESTIONS.log (Pending)

Contains unanswered questions from models or flagged user questions:

```
[2025-10-03 10:30:45] PENDING | claude | PRIORITY:NORMAL | Should I optimize for speed or clarity?
[2025-10-03 10:35:12] PENDING | qwen2.5-7b-instruct-1m | PRIORITY:URGENT | Conflicting requirements in spec
```

### QUESTIONS_ANSWERED.log (Archive)

Contains answered questions with both Q and A:

```
[2025-10-03 10:40:00] ANSWERED | claude | PRIORITY:NORMAL
  Q: Should I optimize for speed or clarity?
  A: Clarity first, then optimize hot paths

[2025-10-03 10:45:30] ANSWERED | qwen2.5-7b-instruct-1m | PRIORITY:URGENT
  Q: Conflicting requirements in spec
  A: Use approach from section 3.2, ignore outdated section 1.5
```

---

## üîÑ Workflow

### For Models (Claude, qwen, etc.)

1. **Work normally** on current task
2. **Before commits**, check if questions pending:
   ```bash
   perl question-answer-system.pl --show
   ```
3. **If urgent questions**, handle immediately:
   - Save current work state
   - Address urgent question
   - Log follow-up if needed
   - Resume or pivot based on answer
4. **If normal questions**, decide:
   - Continue work and answer later
   - Pause to clarify now
   - Log own question for user
5. **After commits**, git hook auto-checks for new QUESTION/ANSWER files

### For User

**To Ask Question**:
```bash
echo "Your question here" > QUESTION          # General
echo "Your question here" > QUESTION.claude   # Specific model
git add QUESTION* && git commit -m "Question" && git push
```

**To Answer Question**:
```bash
# First, see pending questions
perl question-answer-system.pl --show

# Then provide answer
echo "Your answer here" > ANSWER
git add ANSWER && git commit -m "Answer" && git push
```

**To Check Status**:
```bash
perl question-answer-system.pl --show    # See pending
cat QUESTIONS_ANSWERED.log               # See history
```

---

## üõ†Ô∏è Commands

### question-answer-system.pl

```bash
# Check for QUESTION/ANSWER files and process them
perl question-answer-system.pl --check

# Show pending questions
perl question-answer-system.pl --show

# Log a question from model
perl question-answer-system.pl --log "question text" --target claude --priority URGENT

# View answered archive
perl question-answer-system.pl --archive

# Full status report
perl question-answer-system.pl --status
```

---

## üé® Use Cases

### Use Case 1: Model Needs Clarification

**Model** (in work):
```perl
# Model realizes ambiguity in requirements
system('perl question-answer-system.pl --log "Section 3.2 conflicts with 1.5 - which to follow?" --priority URGENT');

# Save current state
git_commit("Save work before pausing for clarification");

# Continue or wait based on priority
```

**User**:
```bash
# See pending question
perl question-answer-system.pl --show

# Provide answer
echo "Follow section 3.2, section 1.5 is outdated" > ANSWER
git add ANSWER && git commit -m "Clarification" && git push
```

**Model** (next session or after commit):
```bash
# Git hook shows: "Answer received!"
# Read answer, proceed with section 3.2
```

### Use Case 2: User Wants to Redirect

**User** (model working on task A):
```bash
echo "URGENT: Stop task A, critical bug in task B needs immediate attention" > QUESTION
git add QUESTION && git commit -m "Redirect to bug" && git push
```

**Model** (after commit):
```bash
# Git hook detects urgent question
# Model sees: "URGENT: Stop task A..."
# Saves task A state
# Switches to task B
```

### Use Case 3: Async Feedback Loop

**Model**:
```perl
# Model completes work
system('perl question-answer-system.pl --log "Filesystem integration complete - review before network phase?"');
git_commit("Complete filesystem integration");
```

**User** (later):
```bash
# Reviews work
# Provides feedback
echo "Looks good! Proceed with network phase. Consider adding error handling in mount.pl:42" > ANSWER
git add ANSWER && git commit -m "Approve + feedback" && git push
```

**Model** (next session):
```bash
# Sees approval
# Notes feedback about error handling
# Proceeds to network phase
```

---

## üîê Protocol-7 Integration

### Core Principles

**Non-Destructive**:
- Questions logged, never lost
- Answers archived permanently
- Complete conversation history

**Resumable**:
- Models save state before handling urgent questions
- Can resume from any point
- Git commits provide checkpoints

**Verifiable**:
- All Q&A in git history
- Timestamped and auditable
- Clear attribution

**Asynchronous**:
- Non-blocking communication
- Models choose when to respond
- Natural workflow integration

**Harmonic**:
- Git hooks provide rhythm
- Out-of-band doesn't interrupt flow
- Self-organizing priority handling

---

## üìä Benefits

### For Models

- ‚úÖ **Autonomy**: Don't stop for every question
- ‚úÖ **Context**: See question history
- ‚úÖ **Flexibility**: Choose when to respond
- ‚úÖ **Safety**: Save state before pivoting

### For Users

- ‚úÖ **Non-Blocking**: Don't interrupt ongoing work
- ‚úÖ **Persistent**: Questions never lost
- ‚úÖ **Targeted**: Can ask specific models
- ‚úÖ **Urgent Handling**: Flag critical questions

### For Collaboration

- ‚úÖ **Async**: Time-zone independent
- ‚úÖ **Multi-Model**: Each handles their questions
- ‚úÖ **Archived**: Complete communication history
- ‚úÖ **Git-Native**: Uses existing infrastructure

---

## üöÄ Advanced Features

### Priority Levels

- **URGENT**: Model should pause current work
- **NORMAL**: Model handles at next checkpoint
- **LOW**: Model handles when convenient

### Targeting

- `QUESTION` - Any model can answer
- `QUESTION.claude` - Specifically for Claude
- `QUESTION.qwen2.5-7b-instruct-1m` - For qwen model
- `QUESTION.copilot` - For Copilot

### Chaining

Questions can reference previous Q&A:
```bash
echo "Follow-up to previous answer about section 3.2: Should we also update docs?" > QUESTION
```

---

## üéØ Best Practices

### For Models

1. **Check before commits**: `perl question-answer-system.pl --show`
2. **Save state for urgent**: Don't lose work
3. **Log own questions**: Don't assume, ask
4. **Reference context**: Mention what you're working on

### For Users

1. **Be specific**: Clear questions get clear answers
2. **Use URGENT sparingly**: Reserve for actual emergencies
3. **Target when needed**: Use QUESTION.<model> for specific expertise
4. **Provide context**: Reference files, line numbers, etc.

---

## üìù File Locations

- `QUESTIONS.log` - Pending questions (at repo root)
- `QUESTIONS_ANSWERED.log` - Answered archive (at repo root)
- `QUESTION` or `QUESTION.<model>` - Temporary (auto-deleted)
- `ANSWER` - Temporary (auto-deleted)
- `.git/hooks/post-commit` - Git hook (auto-checks)
- `question-answer-system.pl` - System script

---

## üîÑ Integration with Models

Models should integrate this check at natural points:

```perl
# Before major commits
system('perl question-answer-system.pl --check');

# Show any pending for this model
system('perl question-answer-system.pl --show --target $MODEL_NAME');

# If urgent questions exist, handle them
if (urgent_questions_pending()) {
    save_current_state();
    handle_urgent_questions();
    decide_next_action();
}
```

---

**Status**: ‚úÖ Operational  
**Integration**: Git post-commit hook  
**Protocol-7**: Fully aligned

---

*"Questions are signals. Answers are harmonics. Communication is the protocol."*
EOF

    open my $fh, '>', $doc_file or die "Cannot create documentation: $!";
    print $fh $doc_content;
    close $fh;
    
    say "‚úÖ Created documentation: $doc_file";
}

# Main execution
my $action = $ARGV[0] // '--status';

if ($action eq '--check') {
    check_question_files();
    check_answer_files();
} elsif ($action eq '--show') {
    show_pending_questions();
} elsif ($action eq '--log') {
    my $question = $ARGV[1] or die "Usage: --log \"question\" [--target model] [--priority URGENT|NORMAL]\n";
    my $target = 'any-model';
    my $priority = 'NORMAL';
    
    for my $i (2..$#ARGV) {
        if ($ARGV[$i] eq '--target' && defined $ARGV[$i+1]) {
            $target = $ARGV[$i+1];
        } elsif ($ARGV[$i] eq '--priority' && defined $ARGV[$i+1]) {
            $priority = uc($ARGV[$i+1]);
        }
    }
    
    log_question($target, $question, $priority);
} elsif ($action eq '--archive') {
    if (-f $questions_answered_log) {
        system("cat '$questions_answered_log'");
    } else {
        say "No answered questions yet";
    }
} elsif ($action eq '--setup') {
    say "üîß SETTING UP QUESTION-ANSWER SYSTEM";
    say "-" x 80;
    say "";
    create_git_hook();
    generate_documentation();
    say "";
    say "=" x 80;
    say "‚úÖ SETUP COMPLETE";
    say "=" x 80;
} elsif ($action eq '--status') {
    check_question_files();
    check_answer_files();
    show_pending_questions();
    say "";
    say "=" x 80;
    say "üìä SYSTEM STATUS";
    say "-" x 80;
    
    # Count pending
    open my $fh, '<', $questions_log or die $!;
    my @pending = grep { /PENDING/ } <$fh>;
    close $fh;
    
    # Count answered
    my $answered_count = 0;
    if (-f $questions_answered_log) {
        open my $fh, '<', $questions_answered_log or die $!;
        $answered_count = grep { /ANSWERED/ } <$fh>;
        close $fh;
    }
    
    say "  Pending questions: " . scalar(@pending);
    say "  Answered (archived): $answered_count";
    say "  Git hook: " . (-f "$repo_root/.git/hooks/post-commit" ? "‚úÖ Installed" : "‚ùå Not installed");
    say "";
    
    if (@pending) {
        say "‚ö†Ô∏è  Action needed: " . scalar(@pending) . " pending question(s)";
    } else {
        say "‚úÖ No pending questions";
    }
    say "=" x 80;
} else {
    say "Usage: question-answer-system.pl [--check|--show|--log|--archive|--setup|--status]";
    say "";
    say "Commands:";
    say "  --check     Check for QUESTION/ANSWER files and process";
    say "  --show      Show pending questions";
    say "  --log       Log a question from model";
    say "  --archive   View answered questions archive";
    say "  --setup     Install git hook and create docs";
    say "  --status    Show system status (default)";
}

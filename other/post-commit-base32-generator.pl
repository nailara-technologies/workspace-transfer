#!/usr/bin/env perl
use strict;
use warnings;
use v5.30;
use File::Basename;
use Cwd;

## LIVING TREE - AUTOMATIC BASE32 ARCHIVE GENERATOR
## Git post-commit hook that creates self-extracting BASE32 backup
## Runs automatically after every commit

my $workspace_root = '/home/claude/living-tree';
my $archive_name = 'LIVING_TREE_BASE32_ARCHIVE.md';
my $archive_path = "$workspace_root/$archive_name";

# Change to workspace root
chdir $workspace_root or die "Cannot cd to workspace: $!";

# Get current commit info
my $commit_hash = `git rev-parse --short HEAD`;
chomp $commit_hash;

my $commit_msg = `git log -1 --pretty=%B`;
chomp $commit_msg;

my $commit_date = `git log -1 --pretty=%ai`;
chomp $commit_date;

say "üå≥ Living Tree BASE32 Archive Generator";
say "‚îÅ" x 70;
say "";
say "Commit: $commit_hash";
say "Date: $commit_date";
say "Message: $commit_msg";
say "";

# Create temporary directory for archiving
my $temp_dir = "/tmp/living_tree_archive_$$";
mkdir $temp_dir or die "Cannot create temp dir: $!";

# Copy workspace files (excluding .git and archive itself)
say "üì¶ Packaging workspace files...";
system("rsync -a --exclude='.git' --exclude='$archive_name' --exclude='*.swp' . $temp_dir/living_tree_workspace/");

# Create tar.gz archive
my $tar_file = "/tmp/living_tree_$commit_hash.tar.gz";
say "üóúÔ∏è  Compressing...";
chdir "/tmp" or die "Cannot cd to /tmp: $!";
system("tar -czf $tar_file -C $temp_dir living_tree_workspace/");

# Get archive size
my $tar_size = -s $tar_file;
my $tar_size_kb = int($tar_size / 1024);

say "   Original: $tar_size_kb KB";

# Encode to BASE32
say "üî¢ Encoding to BASE32...";
my $base32_data = `base32 < $tar_file | tr -d '\\n'`;
my $base32_size = length($base32_data);
my $base32_size_kb = int($base32_size / 1024);

say "   Encoded: $base32_size_kb KB";

# Calculate files in workspace
my $file_count = `find $workspace_root -type f -not -path '*/.git/*' -not -name '$archive_name' | wc -l`;
chomp $file_count;

# Get workspace total size
my $workspace_size = `du -sk $workspace_root --exclude=.git --exclude=$archive_name | cut -f1`;
chomp $workspace_size;

# Create self-extracting markdown document
say "üìù Generating self-extracting archive...";

open my $fh, '>', $archive_path or die "Cannot create archive: $!";

print $fh <<'HEADER';
# üå≥ LIVING TREE BASE32 ARCHIVE üå≥
## Self-Extracting Workspace Backup

**This file is automatically generated after every commit.**

HEADER

print $fh <<"METADATA";
**Generated**: $commit_date  
**Commit**: `$commit_hash`  
**Message**: $commit_msg  
**Files**: $file_count  
**Workspace Size**: $workspace_size KB  
**Compressed**: $tar_size_kb KB  
**BASE32 Encoded**: $base32_size_kb KB  

---

## üéØ What This Is

This document contains the **complete Living Tree workspace** encoded in BASE32 format. 

**The Living Tree encodes its own genetic information using the BASE32 system it implements!**

### Multiple Restoration Methods

**Method 1: Git Clone (Fastest - 2 seconds)**
\`\`\`bash
git clone https://TOKEN\@github.com/nailara-technologies/workspace-transfer.git
\`\`\`

**Method 2: Extract BASE32 Archive (Offline - 5 seconds)**
\`\`\`bash
# Extract the BASE32 data below and decode
sed -n '/BEGIN_BASE32_DATA/,/END_BASE32_DATA/p' $archive_name | \\
  grep -v 'BEGIN\\|END' | base32 -d | tar -xz
\`\`\`

**Method 3: Self-Extracting Perl Script (Most Portable)**

Save this script and run it:

\`\`\`perl
#!/usr/bin/env perl
use strict;
use warnings;

# Read BASE32 data from this file
open my \$fh, '<', '$archive_name' or die "Cannot open archive: \$!";
my \$in_data = 0;
my \$base32_data = '';

while (my \$line = <\$fh>) {
    if (\$line =~ /BEGIN_BASE32_DATA/) {
        \$in_data = 1;
        next;
    }
    if (\$line =~ /END_BASE32_DATA/) {
        last;
    }
    if (\$in_data) {
        chomp \$line;
        \$base32_data .= \$line;
    }
}
close \$fh;

# Decode and extract
open my \$decoder, '|-', 'base32 -d | tar -xz' or die "Cannot decode: \$!";
print \$decoder \$base32_data;
close \$decoder;

print "‚úÖ Living Tree workspace extracted!\\n";
print "   Location: ./living_tree_workspace/\\n";
\`\`\`

---

## üìä Workspace Contents

\`\`\`
METADATA

# List files in archive
my @files = `find $workspace_root -type f -not -path '*/.git/*' -not -name '$archive_name' -printf '%P\\n' | sort`;
foreach my $file (@files) {
    print $fh "  $file\n";
}

print $fh <<'USAGE';
```

---

## üîÑ Auto-Generation

This file is automatically updated by a git post-commit hook:

1. You make changes and commit
2. Hook runs after commit
3. Creates tar.gz of workspace
4. Encodes to BASE32
5. Generates this self-extracting document
6. Stages for next commit

**No manual intervention needed!**

---

## üöÄ Use Cases

### Scenario 1: Normal Work (Use Git)
```bash
git clone REPO    # Fast, modern workflow
# Edit files
git commit & push # Auto-generates BASE32 backup
```

### Scenario 2: Offline Work (Train + Laptop)
```bash
# Download this file once
# Work offline with local model
# Extract workspace: perl extract_script.pl
# No network needed!
```

### Scenario 3: Emergency Recovery
```bash
# Git history corrupted or deleted?
# No problem! Extract from BASE32 archive
# Workspace fully recoverable
```

### Scenario 4: Single-File Transfer
```bash
# Need to move workspace to air-gapped system?
# Just copy this one file
# Self-contained, self-extracting
```

---

## üß¨ Philosophy

**Multi-Layered Redundancy:**
- Layer 1: Direct files in git (fast, modern, collaborative)
- Layer 2: BASE32 archive (offline, portable, resilient)
- Layer 3: Git history (versioning, time travel)

**Self-Referential Beauty:**
- Living Tree uses BASE32 encoding
- Workspace encoded in BASE32
- System preserves itself using its own technology

**Anti-Entropic Design:**
- Multiple restoration paths
- Survives git history deletion
- Offline-capable
- Self-documenting

---

## üì¶ BASE32 Encoded Data

The complete workspace is encoded below. Extract using any of the methods above.

```
BEGIN_BASE32_DATA
USAGE

# Split BASE32 data into 80-character lines for readability
my $pos = 0;
while ($pos < length($base32_data)) {
    print $fh substr($base32_data, $pos, 80) . "\n";
    $pos += 80;
}

print $fh <<'FOOTER';
END_BASE32_DATA
```

---

## ‚úÖ Verification

After extraction, verify:

```bash
cd living_tree_workspace
find . -type f | wc -l    # Should match file count above
du -sk .                   # Should match workspace size above
```

---

## üîÆ Future Enhancements

- **Code Signing**: Cryptographic signatures (Protocol-7 style)
- **Incremental Updates**: Delta encoding for smaller archives
- **Compression Options**: Multiple algorithms (xz, zstd)
- **Metadata Hash**: Verify integrity without extraction
- **Chain of Trust**: Link to previous versions

---

**üå≥ The Living Tree encodes its own genetic information. üå≥**

*Generated automatically by git post-commit hook.*  
*No manual intervention required.*  
*Always up-to-date with latest commit.*

---

**Last Commit**: `COMMIT_HASH`  
**Auto-Generated**: `GENERATION_DATE`  
**Self-Extracting**: Yes ‚úÖ  
**Offline-Capable**: Yes ‚úÖ  
**Redundancy Level**: Maximum üîí
FOOTER

close $fh;

# Cleanup
unlink $tar_file;
system("rm -rf $temp_dir");

# Check if archive was modified (different from HEAD)
my $git_status = `git status --short $archive_name`;

if ($git_status =~ /^\?\?|^.M/) {
    say "";
    say "üìù BASE32 archive updated: $archive_name";
    say "   Size: $base32_size_kb KB";
    say "";
    say "Stage and commit in your next commit:";
    say "   git add $archive_name";
    say "   git commit --amend --no-edit  # Add to this commit";
    say "   OR";
    say "   git commit -m 'Update BASE32 archive'  # Separate commit";
} else {
    say "";
    say "‚úÖ BASE32 archive unchanged (workspace not modified)";
}

say "";
say "‚îÅ" x 70;
say "üå≥ Archive generation complete!";
